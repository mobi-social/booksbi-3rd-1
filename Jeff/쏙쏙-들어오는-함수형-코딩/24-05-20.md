## ~ 24-05-20 읽은 내용 정리

### 📖 pages 
~ 265 p

<br/>
<br/>

### 🔥 요점 정리

"코드의 냄새: 함수 이름에 있는 암묵적 인자"

<br/>

#### 추상화 벽(API) 를 사용할 경우, 독립적일 수도 있고 의존적일 수도 있다.
- 추상화 벽 위의 팀은 api 를 통해 직접적인 구현을 몰라도 개발할 수 있다.
- 그러나 주어진 api 로 구현할 수 없는 기능의 경우, 벽 아래의 팀이 api 를 개발할 때까지 기다려야한다.
- 처음부터 api 를 세세하게 만들어 놓을 경우, 이전 장의 내용에 위배된다.
  - 추상화 벽은 각 팀이 사전에 합의한 사항이자 관리해야 대상이다.
  - 많을수록 관리가 어렵다.
- 추상화 벽의 함수에 "암묵적 인자 드러내기" 리펙토링을 할 경우, 더 유동적이고 다양한 기능을 벽 위의 팀으로 제공할 수 있다.

<br/>

#### "암묵적 인자 드러내기" 리펙토링
- 함수 이름에, 함수 본문에서 다루는 필드명이 있다면 리펙토링 대상이 될 수 있다.
- 함수 이름에 있는 필드 이름이 암묵적 인자이다.
- 암묵적 인자가 확인된다면, 다른 인자와 같이 입력으로 받도록 수정하자.
- "암묵적 인자 드러내기" 리펙토링을 하면, 중복된 함수 선언을 줄일 수 있다.

#### "함수 본문을 콜백으로 바꾸기" 리펙토링
- 반복되는 구문? 로직? 이 여러 함수에 나타난다면, "함수 본문을 콜백으로 바꾸기" 리펙토링 대상이 될 수 있다.
- 반복 구문을 제외한 나머지 로직을 별도 함수로 분리해 인자로 전달받도록 수정하는 것이, 이것이다.
- 외부에서 전달받는 함수을 콜백(callback) 혹은 일급함수 라고 한다.
- 동작을 추상화할 수 있다.

<br/>
<br/>

### 💡 느낀점

이번 장은 전반적으로 유익하다고 느꼈다.
바로 적용할 수 있는 리펙토링 기술을 배워간다.!

"chaeg-check" 프로젝트를 진행하면서 다음과 같은 함수를 선언한 적이 있다.
- `getBookDetailFromAladin()`
- `getBookDetailFromPeanut()` 
둘 다,책에 대한 상세 정보를 받기위한 api 호출 코드였다. 
하지만 api 호출 서버가 달라 이를 명시하기 위해, 함수 이름에 서버의 별칭을 적어두었다.
오늘 보았던 내용대로라면, `Aladin` 과 `Peanut` 은 암묵적 인자인 것 같다.
내부 구현은 거의 동일했었기 때문에, "암묵적 인자 드러내기" 리펙토링 을 진행할 경우 효과적일 것 같다.

함수의 인자로 함수를 받는 코드는 그동안 자주 사용해본 적이 없다.
오히려, 코드 흐름이 망가뜨릴 것 같아 망설였기 때문이다.
하지만 이것도 어떻게 설계하냐에 따라 다를 수 있다고 생각했다.
반복되는 로직(일반화 시킬 부분) 과 그 외 부분을 적절히 나누고, 추상화한다면 읽기 좋은 논리흐름을 만들 수 있을 것 같다.
물론 반복적인 부분이 보인다고 무조건 "함수 본문을 콜백으로 바꾸기" 리펙토링 을 시도하진 않을 것이다.

<br/>
<br/>

### 👾 개념정리

#### 일급
- 함수의 인자로 전달할 수 있는 값 혹은 함수
- 연산자, 반복문, 조건문 등은 일급이 아니다.
  - 이를 (함수로 만들어) 일급으로 바꾸면, 인자로 넘길 수 있다.

#### 고차함수
- 함수를 받거나, 함수를 리턴하는 함수
- 인자에 일급함수가 있다면 그것은 고차함수다.